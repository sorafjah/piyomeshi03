<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>ãƒ”ãƒ¨é£¯ï¼ˆPiyo-Meshiï¼‰</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overscroll-behavior: none;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Sans JP",
                   "Segoe UI Emoji", "Noto Color Emoji", sans-serif;
    }
    canvas {
      touch-action: none;
    }
  </style>
</head>
<body class="bg-sky-200 flex items-center justify-center min-h-screen">
  <!-- ã‚²ãƒ¼ãƒ æ  -->
  <div id="game-wrapper" class="relative w-full max-w-md aspect-[9/16] bg-sky-300 rounded-3xl shadow-xl overflow-hidden">
    <canvas id="game-canvas" class="w-full h-full touch-none"></canvas>

    <!-- ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢ -->
    <div id="start-screen"
         class="absolute inset-0 flex flex-col items-center justify-center bg-black/40 text-white z-20">
      <div class="text-4xl font-bold mb-4 drop-shadow">ğŸ£ ãƒ”ãƒ¨é£¯</div>
      <div class="text-lg mb-6 px-6 text-center">
        è½ã¡ã¦ãã‚‹ã”ã¯ã‚“ã‚’ã‚¸ãƒ£ãƒ³ãƒ—ã§æ‰“ã¡è¿”ã—ã¦ã€<br>
        ç©ºã®ãƒ’ãƒ¨ã‚³ã«é£Ÿã¹ã•ã›ã¦è‚²ã¦ã‚ˆã†ï¼
      </div>
      <button id="start-button"
              class="px-6 py-3 bg-amber-400 text-slate-900 font-bold rounded-full shadow-lg active:scale-95">
        ã‚¿ãƒƒãƒ—ã§ã‚¹ã‚¿ãƒ¼ãƒˆ
      </button>
      <div class="mt-4 text-sm text-amber-100">
        å·¦å³ã‚¹ãƒ¯ã‚¤ãƒ—ï¼šç§»å‹• / ã‚·ãƒ³ã‚°ãƒ«ã‚¿ãƒƒãƒ—ï¼šã‚¸ãƒ£ãƒ³ãƒ— / é•·æŠ¼ã—ï¼šé£Ÿã¹ã‚‹ãƒ»ãƒ€ãƒ³ã‚µãƒ¼ã‚’ä»²é–“ã«
      </div>
    </div>

    <!-- ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ç”»é¢ -->
    <div id="gameover-screen"
         class="hidden absolute inset-0 flex flex-col items-center justify-center bg-black/60 text-white z-20">
      <div class="text-3xl font-bold mb-3">ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼</div>
      <div class="bg-slate-900/70 rounded-2xl px-6 py-4 text-sm space-y-1 mb-4">
        <div>ğŸ“ ã™ãã™ãè‚²ã£ãŸæ•°ï¼š<span id="stat-chickens" class="font-bold">0</span> ç¾½</div>
        <div>ğŸ’ƒ ä»²é–“ã«ã—ãŸãƒ€ãƒ³ã‚µãƒ¼ï¼š<span id="stat-dancers" class="font-bold">0</span> äºº</div>
        <div>â­ ã‚¹ã‚³ã‚¢ï¼š<span id="stat-score" class="font-bold">0</span></div>
        <div>ğŸ‘‘ ãƒã‚¤ã‚¹ã‚³ã‚¢ï¼š<span id="stat-highscore" class="font-bold">0</span></div>
      </div>
      <button id="retry-button"
              class="px-6 py-3 bg-emerald-400 text-slate-900 font-bold rounded-full shadow-lg active:scale-95">
        ã‚‚ã†ä¸€åº¦ã‚ãã¶
      </button>
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('game-canvas');
      const ctx = canvas.getContext('2d');

      const startScreen = document.getElementById('start-screen');
      const startButton = document.getElementById('start-button');
      const gameoverScreen = document.getElementById('gameover-screen');
      const retryButton = document.getElementById('retry-button');

      const statChickens = document.getElementById('stat-chickens');
      const statDancers  = document.getElementById('stat-dancers');
      const statScore    = document.getElementById('stat-score');
      const statHighscore= document.getElementById('stat-highscore');

      // ç”»é¢ã‚µã‚¤ã‚º
      let width = 0, height = 0, groundY = 0;

      function resizeCanvas() {
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        width = rect.width * dpr;
        height = rect.height * dpr;
        canvas.width = width;
        canvas.height = height;
        groundY = height * 0.88;
      }
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();

      // ã‚²ãƒ¼ãƒ ã‚¹ãƒ†ãƒ¼ãƒˆ
      let gameState = 'title'; // 'title' | 'playing' | 'gameover'

      const player = {
        x: 0,
        y: 0,
        vy: 0,
        radius: 28,
        onGround: true,
        stamina: 100,
        staminaMax: 100,
        lives: 3,
        wobble: 0,
        invincibleTimer: 0,
        stunTimer: 0,
        respawnTimer: 0
      };

      let foods = [];
      let birds = [];
      let enemies = [];
      let dancersFloating = [];
      let partner = null;
      let heartEffects = [];

      let score = 0;
      let highScore = parseInt(localStorage.getItem('piyomeshi_highscore') || '0', 10);
      let chickensGrown = 0;
      let dancersCollected = 0;
      let chickensCombo = 0;

      let feverActive = false;
      let feverTimer = 0;

      let foodSpawnTimer = 0;
      let enemySpawnTimer = 0;
      let dancerSpawnTimer = 0;

      // ã‚¿ãƒƒãƒå…¥åŠ›
      let isTouching = false;
      let touchStartX = 0, touchStartY = 0, touchStartTime = 0;
      let lastTouchX = 0, lastTouchY = 0;
      let touchMoved = false;
      let longPressTimeoutId = null;
      const TAP_MAX_DURATION = 200;   // ms
      const TAP_MOVE_TOL = 20;       // px
      const LONGPRESS_DURATION = 500; // ms

      function worldXFromClient(clientX) {
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        const ratio = (clientX - rect.left) / rect.width;
        return ratio * width;
      }

      // åˆæœŸåŒ–
      function resetGame() {
        player.x = width / 2;
        player.y = groundY;
        player.vy = 0;
        player.onGround = true;
        player.stamina = player.staminaMax;
        player.lives = 3;
        player.invincibleTimer = 0;
        player.stunTimer = 0;
        player.respawnTimer = 0;

        foods = [];
        birds = [];
        enemies = [];
        dancersFloating = [];
        partner = null;
        heartEffects = [];

        score = 0;
        chickensGrown = 0;
        dancersCollected = 0;
        chickensCombo = 0;
        feverActive = false;
        feverTimer = 0;

        foodSpawnTimer = 1.0;
        enemySpawnTimer = 2.5;
        dancerSpawnTimer = 8.0;

        // ä¸Šã«2ç¾½ã®ãƒ’ãƒ¨ã‚³ç”Ÿæˆ
        birds.push(makeBird(width * 0.25));
        birds.push(makeBird(width * 0.75));
      }

      function makeBird(x) {
        return {
          x,
          baseY: height * 0.15,
          vx: (Math.random() < 0.5 ? -1 : 1) * (width * 0.03),
          stage: 0, // 0:ğŸ£,1:ğŸ¥,2:ğŸ“
          t: Math.random() * Math.PI * 2,
          flyAway: false
        };
      }

      function spawnFood() {
        const emojis = ['ğŸ', 'ğŸ‡', 'ğŸŒ', 'ğŸ”', 'ğŸ•', 'ğŸ›'];
        const emoji = emojis[Math.floor(Math.random() * emojis.length)];
        foods.push({
          x: width * (0.15 + 0.7 * Math.random()),
          y: height * 0.05,
          vx: (Math.random() - 0.5) * (width * 0.02),
          vy: height * 0.03, // ã‚†ã£ãã‚Šè½ä¸‹
          radius: 20,
          emoji,
          batted: false
        });
      }

      function spawnEnemy() {
        const r = Math.random();
        if (r < 0.33) {
          // çŠ¬ï¼ˆæ¨ªï¼‰
          const fromLeft = Math.random() < 0.5;
          enemies.push({
            type: 'dog',
            x: fromLeft ? -40 : width + 40,
            y: groundY - 10,
            vx: (fromLeft ? 1 : -1) * (width * 0.05),
            vy: 0,
            radius: 26,
            t: Math.random() * Math.PI * 2
          });
        } else if (r < 0.66) {
          // é›·ï¼ˆä¸Šã‹ã‚‰ï¼‰
          enemies.push({
            type: 'lightning',
            x: width * (0.15 + 0.7 * Math.random()),
            y: -40,
            vx: 0,
            vy: height * 0.20,
            radius: 24
          });
        } else {
          // çˆ†å¼¾ï¼ˆä¸Šã‹ã‚‰ï¼‰
          enemies.push({
            type: 'bomb',
            x: width * (0.15 + 0.7 * Math.random()),
            y: -40,
            vx: 0,
            vy: height * 0.15,
            radius: 24
          });
        }
      }

      function spawnDancer() {
        dancersFloating.push({
          x: width * (0.2 + 0.6 * Math.random()),
          y: -40,
          vy: height * 0.06,
          radius: 24,
          rotation: Math.random() * Math.PI * 2
        });
      }

      function addScore(pts) {
        score += pts;
        if (score > highScore) {
          highScore = score;
          localStorage.setItem('piyomeshi_highscore', String(highScore));
        }
      }

      function startFever() {
        feverActive = true;
        feverTimer = 10.0;
      }

      function endFever() {
        feverActive = false;
      }

      function usePartnerShield(x, y) {
        if (!partner) return false;
        heartEffects.push({
          x,
          y,
          t: 0
        });
        partner = null;
        return true;
      }

      function loseLife() {
        if (player.respawnTimer > 0) return;
        player.lives -= 1;
        chickensCombo = 0; // é€£ç¶šãƒœãƒ¼ãƒŠã‚¹é€”åˆ‡ã‚Œ
        player.vy = -height * 0.5;
        player.onGround = false;
        player.respawnTimer = 1.2;
        player.invincibleTimer = 1.5;
        if (player.lives <= 0) {
          // æœ€å¾Œã®ãƒ©ã‚¤ãƒ•ã€‚respawnTimerçµ‚äº†ã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼
        }
      }

      function applyStaminaDamage(amount) {
        if (feverActive) return; // ãƒ•ã‚£ãƒ¼ãƒãƒ¼ä¸­ã¯ãƒãƒ¼ãƒ€ãƒ¡
        player.stamina -= amount;
        if (player.stamina <= 0) {
          player.stamina = 0;
          loseLife();
        }
      }

      function applyDirectLifeDamage() {
        if (feverActive) return;
        if (usePartnerShield(player.x, player.y - 30)) return;
        loseLife();
      }

      function healStamina(amount) {
        player.stamina = Math.min(player.staminaMax, player.stamina + amount);
      }

      function distance2(ax, ay, bx, by) {
        const dx = ax - bx;
        const dy = ay - by;
        return dx * dx + dy * dy;
      }

      // å…¥åŠ›å‡¦ç†
      function clearLongPressTimer() {
        if (longPressTimeoutId !== null) {
          clearTimeout(longPressTimeoutId);
          longPressTimeoutId = null;
        }
      }

      function handleTap() {
        if (gameState !== 'playing') return;
        if (player.stunTimer > 0 || player.respawnTimer > 0) return;
        if (player.onGround) {
          player.vy = -height * 0.55;
          player.onGround = false;
          applyStaminaDamage(5); // ã‚¸ãƒ£ãƒ³ãƒ—ã§ä½“åŠ›æ¶ˆè²»
        }
      }

      function handleLongPress() {
        if (gameState !== 'playing') return;
        if (player.stunTimer > 0 || player.respawnTimer > 0) return;

        longPressTimeoutId = null;

        // è¿‘ãã®é£Ÿã¹ç‰©ã‚’é£Ÿã¹ã¦ä½“åŠ›å›å¾©
        let ate = false;
        for (let i = 0; i < foods.length; i++) {
          const f = foods[i];
          const r2 = distance2(player.x, player.y - 20, f.x, f.y);
          if (r2 < Math.pow(player.radius + f.radius, 2)) {
            foods.splice(i, 1);
            healStamina(20);
            ate = true;
            break;
          }
        }
        if (ate) return;

        // é£Ÿã¹ç‰©ãŒãªã‘ã‚Œã°ãƒ€ãƒ³ã‚µãƒ¼ã‚’ä»²é–“ã«ã™ã‚‹
        for (let i = 0; i < dancersFloating.length; i++) {
          const d = dancersFloating[i];
          const r2 = distance2(player.x, player.y - 20, d.x, d.y);
          if (r2 < Math.pow(player.radius + d.radius, 2)) {
            partner = {
              x: d.x,
              y: d.y,
              radius: 24
            };
            dancersFloating.splice(i, 1);
            dancersCollected++;
            break;
          }
        }
      }

      function onTouchStart(e) {
        e.preventDefault();
        if (e.touches.length === 0) return;

        const t = e.touches[0];
        isTouching = true;
        touchMoved = false;
        touchStartX = t.clientX;
        touchStartY = t.clientY;
        lastTouchX = t.clientX;
        lastTouchY = t.clientY;
        touchStartTime = performance.now();

        clearLongPressTimer();
        longPressTimeoutId = setTimeout(() => {
          if (!isTouching) return;
          const dx = lastTouchX - touchStartX;
          const dy = lastTouchY - touchStartY;
          if (Math.hypot(dx, dy) < TAP_MOVE_TOL) {
            handleLongPress();
          }
        }, LONGPRESS_DURATION);
      }

      function onTouchMove(e) {
        e.preventDefault();
        if (!isTouching || e.touches.length === 0) return;

        const t = e.touches[0];
        const dx = t.clientX - touchStartX;
        const dy = t.clientY - touchStartY;
        lastTouchX = t.clientX;
        lastTouchY = t.clientY;

        if (Math.hypot(dx, dy) > TAP_MOVE_TOL) {
          touchMoved = true;
        }

        // æ¨ªã‚¹ãƒ¯ã‚¤ãƒ—ã§ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç§»å‹•ï¼ˆæŒ‡ã®ä½ç½®ã«è¿½å¾“ï¼‰
        if (gameState === 'playing') {
          const worldX = worldXFromClient(t.clientX);
          const target = Math.max(player.radius, Math.min(width - player.radius, worldX));
          // æ»‘ã‚‰ã‹ã«å¯„ã‚‹
          const lerp = 0.25;
          player.x = player.x + (target - player.x) * lerp;
        }
      }

      function onTouchEnd(e) {
        e.preventDefault();
        clearLongPressTimer();
        if (!isTouching) return;
        isTouching = false;

        const elapsed = performance.now() - touchStartTime;
        const dx = lastTouchX - touchStartX;
        const dy = lastTouchY - touchStartY;

        if (elapsed <= TAP_MAX_DURATION && Math.hypot(dx, dy) < TAP_MOVE_TOL) {
          // ã‚·ãƒ³ã‚°ãƒ«ã‚¿ãƒƒãƒ—
          if (gameState === 'title') {
            startGame();
          } else if (gameState === 'gameover') {
            startGame();
          } else {
            handleTap();
          }
        }
      }

      canvas.addEventListener('touchstart', onTouchStart, {passive: false});
      canvas.addEventListener('touchmove', onTouchMove, {passive: false});
      canvas.addEventListener('touchend', onTouchEnd, {passive: false});
      canvas.addEventListener('touchcancel', onTouchEnd, {passive: false});

      startButton.addEventListener('click', () => startGame());
      retryButton.addEventListener('click', () => startGame());

      // ã‚²ãƒ¼ãƒ é–‹å§‹
      function startGame() {
        resetGame();
        gameState = 'playing';
        startScreen.classList.add('hidden');
        gameoverScreen.classList.add('hidden');
      }

      function showGameOver() {
        gameState = 'gameover';
        statChickens.textContent = chickensGrown;
        statDancers.textContent = dancersCollected;
        statScore.textContent = score;
        statHighscore.textContent = highScore;
        gameoverScreen.classList.remove('hidden');
      }

      // æ›´æ–°
      function update(dt) {
        if (dt > 0.05) dt = 0.05;

        if (gameState === 'title') return;
        if (gameState === 'gameover') return;

        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
        const gravity = height * 1.1;

        if (!player.onGround) {
          player.vy += gravity * dt;
          player.y += player.vy * dt;
          if (player.y >= groundY) {
            player.y = groundY;
            player.vy = 0;
            player.onGround = true;
          }
        }

        // ã‚†ã‚‰ã‚†ã‚‰ï¼ˆç§»å‹•ä¸­ã«å°‘ã—æºã‚Œã‚‹ï¼‰
        player.wobble += dt * 6;

        if (player.invincibleTimer > 0) player.invincibleTimer -= dt;
        if (player.stunTimer > 0) player.stunTimer -= dt;

        if (player.respawnTimer > 0) {
          player.respawnTimer -= dt;
          if (player.respawnTimer <= 0) {
            if (player.lives <= 0) {
              showGameOver();
              return;
            } else {
              // å†ã‚¹ã‚¿ãƒ¼ãƒˆ
              player.x = width / 2;
              player.y = groundY;
              player.vy = 0;
              player.onGround = true;
              player.stamina = player.staminaMax;
            }
          }
        }

        // ãƒ•ã‚£ãƒ¼ãƒãƒ¼
        if (feverActive) {
          feverTimer -= dt;
          if (feverTimer <= 0) {
            feverTimer = 0;
            endFever();
          }
        }

        // é£Ÿã¹ç‰©ã‚¹ãƒãƒ¼ãƒ³
        foodSpawnTimer -= dt;
        const maxFood = feverActive ? 4 : 2;
        if (foodSpawnTimer <= 0 && foods.length < maxFood) {
          spawnFood();
          foodSpawnTimer = feverActive
            ? 0.4 + Math.random() * 0.5
            : 1.0 + Math.random() * 1.5;
        }

        // æ•µã‚¹ãƒãƒ¼ãƒ³
        enemySpawnTimer -= dt;
        if (enemySpawnTimer <= 0) {
          spawnEnemy();
          enemySpawnTimer = 2.5 + Math.random() * 2.0;
        }

        // ãƒ€ãƒ³ã‚µãƒ¼ã‚¹ãƒãƒ¼ãƒ³
        dancerSpawnTimer -= dt;
        if (dancerSpawnTimer <= 0) {
          spawnDancer();
          dancerSpawnTimer = 10.0 + Math.random() * 5.0;
        }

        // é£Ÿã¹ç‰©æ›´æ–°
        const gFood = height * 0.35;
        for (let i = foods.length - 1; i >= 0; i--) {
          const f = foods[i];
          // æ¼‚ã†ã‚ˆã†ã«å°‘ã—æ¨ªæºã‚Œ
          f.x += f.vx * dt;
          f.y += f.vy * dt;
          if (f.batted) {
            f.vy += gFood * dt;
          }

          // ç”»é¢ç«¯ã§åå°„
          if (f.x < 20) { f.x = 20; f.vx *= -1; }
          if (f.x > width - 20) { f.x = width - 20; f.vx *= -1; }

          // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨è¡çªï¼ˆæ‰“ã¡è¿”ã—ï¼‰
          if (gameState === 'playing' && !f.batted &&
              distance2(f.x, f.y, player.x, player.y - 10) < Math.pow(f.radius + player.radius * 0.7, 2)) {
            f.batted = true;
            f.vy = -height * 0.45;
          }

          // åœ°é¢ã«è½ã¡ãŸãƒšãƒŠãƒ«ãƒ†ã‚£
          if (f.y > groundY + 10) {
            foods.splice(i, 1);
            applyStaminaDamage(6);
          }
        }

        // ãƒ’ãƒ¨ã‚³æ›´æ–°
        for (const b of birds) {
          b.t += dt * 4;
          const amp = height * 0.015;
          b.y = b.baseY + Math.sin(b.t) * amp;

          if (b.flyAway) {
            b.x += b.vx * dt * 2;
            if (b.x < -60 || b.x > width + 60) {
              // æ–°ã—ã„ğŸ£ã«ç”Ÿã¾ã‚Œå¤‰ã‚ã‚Š
              const idx = birds.indexOf(b);
              if (idx >= 0) {
                birds[idx] = makeBird(Math.random() < 0.5 ? width * 0.25 : width * 0.75);
              }
            }
          } else {
            b.x += b.vx * dt;
            if (b.x < -40) b.x = width + 40;
            if (b.x > width + 40) b.x = -40;
          }
        }

        // é£Ÿã¹ç‰©ã¨ãƒ’ãƒ¨ã‚³ã®å½“ãŸã‚Šåˆ¤å®šï¼ˆé£Ÿã¹ã‚‹ï¼‰
        for (let i = foods.length - 1; i >= 0; i--) {
          const f = foods[i];
          for (const b of birds) {
            if (distance2(f.x, f.y, b.x, b.y) <
              Math.pow(f.radius + 26, 2)) {
              // é£Ÿã¹ã•ã›ã‚‹
              foods.splice(i, 1);
              b.stage = Math.min(2, b.stage + 1);
              addScore(100);
              healStamina(3);

              if (b.stage === 2) { // ğŸ“ã«ãªã£ãŸ
                chickensGrown += 1;
                chickensCombo += 1;
                addScore(1000);
                // ã™ãã™ããƒœãƒ¼ãƒŠã‚¹è¡¨ç¤ºç”¨ã®å°ã•ãªã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
                heartEffects.push({
                  x: b.x,
                  y: b.y - 20,
                  t: 0,
                  text: 'ã™ãã™ããƒœãƒ¼ãƒŠã‚¹ï¼+1000'
                });
                b.flyAway = true;

                if (chickensCombo >= 3 && !feverActive) {
                  chickensCombo = 0;
                  startFever();
                }
              }
              break;
            }
          }
        }

        // æ•µæ›´æ–°
        for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i];
          if (e.type === 'dog') {
            e.x += e.vx * dt;
            e.y = groundY - 10 + Math.sin(e.t) * 6;
            e.t += dt * 4;
            if (e.x < -80 || e.x > width + 80) {
              enemies.splice(i, 1);
              continue;
            }
          } else {
            // è½ä¸‹ç³»ï¼ˆé›·ãƒ»çˆ†å¼¾ï¼‰
            e.y += e.vy * dt;
            if (e.y > groundY + 40) {
              enemies.splice(i, 1);
              continue;
            }
          }

          // å½“ãŸã‚Šåˆ¤å®š
          if (gameState === 'playing' &&
              distance2(e.x, e.y, player.x, player.y - 10) < Math.pow(e.radius + player.radius * 0.7, 2)) {

            if (feverActive) {
              // ãƒ•ã‚£ãƒ¼ãƒãƒ¼ä¸­ã¯æ•µç„¡åŠ¹ã€æ¶ˆãˆã‚‹ã ã‘
              enemies.splice(i, 1);
              continue;
            }

            // ãƒ‘ãƒ¼ãƒˆãƒŠãƒ¼ãŒèº«ä»£ã‚ã‚Š
            if (usePartnerShield(e.x, e.y)) {
              enemies.splice(i, 1);
              continue;
            }

            if (e.type === 'dog') {
              applyStaminaDamage(8);
            } else if (e.type === 'lightning') {
              applyStaminaDamage(12);
              player.stunTimer = 1.0;
            } else if (e.type === 'bomb') {
              applyDirectLifeDamage();
            }
            enemies.splice(i, 1);
          }
        }

        // æµ®éŠãƒ€ãƒ³ã‚µãƒ¼æ›´æ–°
        for (let i = dancersFloating.length - 1; i >= 0; i--) {
          const d = dancersFloating[i];
          d.y += d.vy * dt;
          d.rotation += dt * 4;
          if (d.y > groundY + 50) {
            dancersFloating.splice(i, 1);
          }
        }

        // ãƒ‘ãƒ¼ãƒˆãƒŠãƒ¼è¿½å¾“
        if (partner) {
          partner.x += (player.x - partner.x) * 0.15;
          partner.y += (player.y - 40 - partner.y) * 0.15;
        }

        // ãƒãƒ¼ãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
        for (let i = heartEffects.length - 1; i >= 0; i--) {
          const h = heartEffects[i];
          h.t += dt;
          if (h.text) {
            h.y -= 20 * dt;
          } else {
            h.y -= 30 * dt;
          }
          if (h.t > 1.2) {
            heartEffects.splice(i, 1);
          }
        }
      }

      // æç”»
      function draw() {
        ctx.clearRect(0, 0, width, height);

        // èƒŒæ™¯
        ctx.fillStyle = '#8ecae6';
        ctx.fillRect(0, 0, width, height);

        // åœ°é¢
        ctx.fillStyle = '#2f9e44';
        ctx.fillRect(0, groundY, width, height - groundY);
        ctx.fillStyle = '#7f5539';
        ctx.fillRect(0, groundY + (height - groundY) * 0.15, width, height - groundY);

        // ãƒ’ãƒ¨ã‚³
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        for (const b of birds) {
          const emoji = b.stage === 0 ? 'ğŸ£' : (b.stage === 1 ? 'ğŸ¥' : 'ğŸ“');
          ctx.font = `${Math.round(height * 0.05)}px "Segoe UI Emoji","Noto Color Emoji",system-ui`;
          ctx.fillText(emoji, b.x, b.y);
        }

        // é£Ÿã¹ç‰©
        for (const f of foods) {
          ctx.font = `${Math.round(height * 0.045)}px "Segoe UI Emoji","Noto Color Emoji",system-ui`;
          ctx.fillText(f.emoji, f.x, f.y);
        }

        // æµ®éŠãƒ€ãƒ³ã‚µãƒ¼
        for (const d of dancersFloating) {
          ctx.save();
          ctx.translate(d.x, d.y);
          ctx.rotate(d.rotation);
          ctx.font = `${Math.round(height * 0.05)}px "Segoe UI Emoji","Noto Color Emoji",system-ui`;
          ctx.fillText('ğŸ’ƒ', 0, 0);
          ctx.restore();
        }

        // æ•µ
        for (const e of enemies) {
          ctx.font = `${Math.round(height * 0.05)}px "Segoe UI Emoji","Noto Color Emoji",system-ui`;
          let emoji = 'ğŸ•';
          if (e.type === 'lightning') emoji = 'âš¡';
          if (e.type === 'bomb') emoji = 'ğŸ’£';
          ctx.fillText(emoji, e.x, e.y);
        }

        // ãƒ‘ãƒ¼ãƒˆãƒŠãƒ¼
        if (partner) {
          ctx.font = `${Math.round(height * 0.045)}px "Segoe UI Emoji","Noto Color Emoji",system-ui`;
          ctx.fillText('ğŸ’ƒ', partner.x, partner.y);
        }

        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
        ctx.save();
        ctx.translate(player.x, player.y - player.radius);
        const wobbleY = Math.sin(player.wobble) * 3;
        ctx.translate(0, wobbleY);
        ctx.font = `${Math.round(height * 0.06)}px "Segoe UI Emoji","Noto Color Emoji",system-ui`;
        ctx.fillText('ğŸ•º', 0, 0);
        ctx.restore();

        // ãƒãƒ¼ãƒˆãªã©ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
        for (const h of heartEffects) {
          const alpha = Math.max(0, 1 - h.t);
          ctx.globalAlpha = alpha;
          ctx.font = `${Math.round(height * 0.04)}px "Segoe UI Emoji","Noto Color Emoji",system-ui`;
          if (h.text) {
            ctx.fillStyle = '#ffffff';
            ctx.font = `${Math.round(height * 0.03)}px "Noto Sans JP",system-ui`;
            ctx.fillText(h.text, h.x, h.y);
          } else {
            ctx.fillText('â¤ï¸', h.x, h.y);
          }
          ctx.globalAlpha = 1;
        }

        // UIï¼šä½“åŠ›ã‚²ãƒ¼ã‚¸
        const uiScale = height / 800;
        const barWidth = 220 * uiScale;
        const barHeight = 24 * uiScale;
        const barX = 20 * uiScale;
        const barY = 18 * uiScale;

        ctx.save();
        ctx.translate(barX, barY);
        ctx.fillStyle = 'rgba(148, 163, 184, 0.9)';
        ctx.roundRect(0, 0, barWidth, barHeight, 12 * uiScale);
        ctx.fill();

        ctx.font = `${Math.round(16 * uiScale)}px "Segoe UI Emoji","Noto Color Emoji"`;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        ctx.fillText('ğŸ’ª', 8 * uiScale, barHeight / 2);

        const innerX = 40 * uiScale;
        const innerY = 4 * uiScale;
        const innerW = barWidth - innerX - 6 * uiScale;
        const innerH = barHeight - innerY * 2;
        ctx.fillStyle = 'rgba(51,65,85,0.9)';
        ctx.roundRect(innerX, innerY, innerW, innerH, 10 * uiScale);
        ctx.fill();

        const ratio = player.stamina / player.staminaMax;
        ctx.fillStyle = '#22c55e';
        ctx.roundRect(innerX + 1 * uiScale, innerY + 1 * uiScale,
          (innerW - 2 * uiScale) * ratio, innerH - 2 * uiScale, 8 * uiScale);
        ctx.fill();
        ctx.restore();

        // UIï¼šãƒ©ã‚¤ãƒ•
        ctx.font = `${Math.round(24 * uiScale)}px "Segoe UI Emoji","Noto Color Emoji"`;
        ctx.textAlign = 'left';
        for (let i = 0; i < player.lives; i++) {
          ctx.fillText('â¤ï¸', barX + i * 28 * uiScale, barY + barHeight + 22 * uiScale);
        }

        // UIï¼šã‚¹ã‚³ã‚¢
        ctx.font = `${Math.round(28 * uiScale)}px "Noto Sans JP",system-ui`;
        ctx.textAlign = 'right';
        ctx.textBaseline = 'top';
        ctx.fillStyle = '#ffffff';
        ctx.fillText(score.toString(), width - 24 * uiScale, 14 * uiScale);

        // UIï¼šãƒ•ã‚£ãƒ¼ãƒãƒ¼è¡¨ç¤º
        if (feverActive) {
          ctx.font = `${Math.round(22 * uiScale)}px "Noto Sans JP",system-ui`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'top';
          ctx.fillStyle = '#f97316';
          ctx.fillText('ğŸ”¥ ãƒ•ã‚£ãƒ¼ãƒãƒ¼ï¼', width / 2, 18 * uiScale);
        }
      }

      // ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—
      let lastTime = performance.now();
      function loop(now) {
        const dt = (now - lastTime) / 1000;
        lastTime = now;
        update(dt);
        draw();
        requestAnimationFrame(loop);
      }
      requestAnimationFrame(loop);
    })();
  </script>
</body>
</html>
